package de.androidcrypto.eccryptography;

import android.text.TextUtils;
import android.util.Base64;
import android.util.Log;

import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.UUID;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import de.androidcrypto.eccryptography.model.EcdhModel;

/**
 * This class does all the work with low level methods. It does NOT use the Android Keystore
 * to create and store the EC keys.
 * Security warning: This app exposes the private key and is for demonstration only.
 * The main problem is the secure storage of the private key material generated by the class.
 */

public class EcEncryption {


    private static final String TAG = "EcEncryption";

    public static enum KEY_PARAMETER {
        P_256, P_521
    }

    public static enum KEY_TYPE {
        EC, RSA
    }

    public static KeyPair generateEcKeyPair(KEY_PARAMETER key_parameter) {
        int keyLength;
        if (key_parameter == KEY_PARAMETER.P_256) {
            keyLength = 256;
        } else if (key_parameter == KEY_PARAMETER.P_521) {
            keyLength = 521;
        } else {
            Log.d(TAG, "unsupported key parameter, aborted");
            return null;
        }
        return generateEcKeyPair(keyLength);
    }

    public static KeyPair generateEcKeyPair(int keyLength) {
        // check for allowed key lengths
        if ((keyLength != 256) && (keyLength != 384) && (keyLength != 521)) {
            Log.d(TAG, "Key length has to be 256, 384 or 521, aborted");
            return null;
        }
        KeyPair kp;
        try {
            KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC");
            kpg.initialize(keyLength);
            kp = kpg.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, "Error: " + e.getMessage());
            return null;
        }
        Log.d(TAG, "EC key pair generated with length " + keyLength);
        return kp;
    }

    public static PrivateKey getPrivateKeyFromEncoded(byte[] encodedPrivateKey) {
        if (encodedPrivateKey == null) {
            Log.d(TAG, "encoded Private Key is NULL, aborted");
        }
        KeyFactory kf = null;
        PrivateKey privateKey;
        try {
            kf = KeyFactory.getInstance("EC");
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedPrivateKey);
            privateKey = kf.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            Log.e(TAG, "Error: " + e.getMessage());
            return null;
        }
        Log.d(TAG, "Private Key from encoded generated");
        return privateKey;
    }

    public static PublicKey getPublicKeyFromEncoded(byte[] encodedPublicKey) {
        if (encodedPublicKey == null) {
            Log.d(TAG, "encoded Public Key is NULL, aborted");
        }
        KeyFactory kf = null;
        PublicKey publicKey;
        try {
            kf = KeyFactory.getInstance("EC");
            X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(encodedPublicKey);
            publicKey = kf.generatePublic(pkSpec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            Log.e(TAG, "Error: " + e.getMessage());
            return null;
        }
        Log.d(TAG, "Public Key from encoded generated");
        return publicKey;
    }

    public static byte[] getEcdhSharedSecret(PrivateKey privateKey, PublicKey remotePublicKey) {
        if (privateKey == null) {
            Log.d(TAG, "Private Key is NULL, aborted");
            return null;
        }
        if (remotePublicKey == null) {
            Log.d(TAG, "remote Public Key is NULL, aborted");
            return null;
        }
        KeyAgreement ka = null;
        try {
            ka = KeyAgreement.getInstance("ECDH");
            ka.init(privateKey);
            ka.doPhase(remotePublicKey, true);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            Log.e(TAG, "Error: " + e.getMessage());
            return null;
        }
        Log.d(TAG, "ECDH shared secret generated");
        return ka.generateSecret();
    }

    public static enum HKDF_ALGORITHM {
        HMAC_SHA256, HMAC_SHA512
    }

    public static enum HKDF_NAME {
        AES_KEY
    }

    public static byte[][] deriveEncryptionKeyHkdf(HKDF_ALGORITHM hkdf_algorithm, HKDF_NAME hkdf_name, byte[] sharedSecret) {
        // HKDF algorithm
        HKDF hkdf = null;
        if (hkdf_algorithm.equals(HKDF_ALGORITHM.HMAC_SHA256)) {
            hkdf = HKDF.fromHmacSha256();
        } else if (hkdf_algorithm.equals(HKDF_ALGORITHM.HMAC_SHA512)) {
            hkdf = HKDF.fromHmacSha512();
        } else {
            // at this pint no valid deriveAlgorithm was found
            Log.e(TAG, "no valid HKDF algorithm found, aborted");
            return null;
        }
        if (sharedSecret == null) {
            Log.d(TAG, "shared secret is NULL, aborted");
        }
        byte[][] result = new byte[2][];
        // generate a random salt
        byte[] randomSalt32Byte = generateRandomNumber(32);
        byte[] pseudoRandomKey;
        pseudoRandomKey = hkdf.extract(randomSalt32Byte, sharedSecret);
        // create expanded bytes for e.g. AES secret key
        result[0] = hkdf.expand(pseudoRandomKey, hkdf_name.toString().getBytes(StandardCharsets.UTF_8), 32);
        result[1] = randomSalt32Byte;
        return result;
    }

    public static byte[] getEncryptionKeyHkdf(HKDF_ALGORITHM hkdf_algorithm, HKDF_NAME hkdf_name, byte[] sharedSecret, byte[] salt) {
        // HKDF algorithm
        HKDF hkdf = null;
        if (hkdf_algorithm.equals(HKDF_ALGORITHM.HMAC_SHA256)) {
            hkdf = HKDF.fromHmacSha256();
        } else if (hkdf_algorithm.equals(HKDF_ALGORITHM.HMAC_SHA512)) {
            hkdf = HKDF.fromHmacSha512();
        } else {
            // at this pint no valid deriveAlgorithm was found
            Log.e(TAG, "no valid HKDF algorithm found, aborted");
            return null;
        }
        if (sharedSecret == null) {
            Log.d(TAG, "shared secret is NULL, aborted");
        }
        // generate a random salt
        byte[] pseudoRandomKey;
        pseudoRandomKey = hkdf.extract(salt, sharedSecret);
        // create expanded bytes for e.g. AES secret key
        return hkdf.expand(pseudoRandomKey, hkdf_name.toString().getBytes(StandardCharsets.UTF_8), 32);
    }

    public static enum ENCRYPTION_ALGORITHM {
        AES_CBC_PKCS5PADDING, AES_GCM_NOPADDING
    }

    public static EcdhModel encryptAes(String deriveAlgorithm, String encryptionAlgorithm, String transformation, String aliasRecipient, byte[] deriveSalt, String deriveName, byte[] encryptionKey, byte[] data) {
        // todo check for encryptionAlgorithm allowed, nulled key + data
        //String encAlgo = EcdhModel.ENCRYPTION_TYPE.AES_CBC_PKCS5PADDING.toString();
        //String encAlgorithm = "AES/CBC/PKCS5PADDING";
        // todo cases CBC or GCM
        byte[] initVector = new byte[0];
        byte[] ciphertext;
        SecretKey key;
        key = new SecretKeySpec(encryptionKey, "AES"); //AES-256 key
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance(transformation);
            if (encryptionAlgorithm.equals(EcdhModel.ENCRYPTION_ALGORITHM.AES_CBC_PKCS5PADDING.toString())) {
                initVector = generateRandomNumber(16);
                cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(initVector));
            } else if (encryptionAlgorithm.equals(EcdhModel.ENCRYPTION_ALGORITHM.AES_GCM_NOPADDING.toString())) {
                initVector = generateRandomNumber(12);
                cipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(16, initVector));
            }
            ciphertext = cipher.doFinal(data);
        } catch (NoSuchAlgorithmException | IllegalBlockSizeException |
                 BadPaddingException | NoSuchPaddingException |
                 InvalidAlgorithmParameterException | InvalidKeyException e) {
            //throw new RuntimeException(e);
            return null;
        }
        // build the return model
        //return new EcdhModel(alias, base64EncodingNpe(deriveSalt), deriveName, encryptionAlgorithm, base64EncodingNpe(initVector), base64EncodingNpe(ciphertext));
        return new EcdhModel(aliasRecipient, base64EncodingNpe(deriveSalt), deriveName, deriveAlgorithm, encryptionAlgorithm, base64EncodingNpe(initVector), base64EncodingNpe(ciphertext));
    }

    public static byte[] decryptAes(String encryptionAlgorithm, String transformation, String alias, byte[] encryptionKey, byte[] initVector, byte[] ciphertext) {
        //public static byte[] decryptAes(EcdhModel encryptedData, PrivateKey recipientPrivateKey, PublicKey senderPublicKey) {
        // todo get the private key by the keyId

        // todo check for encryptionAlgorithm allowed, nulled key + data
        //String encAlgo = EcdhModel.ENCRYPTION_TYPE.AES_CBC_PKCS5PADDING.toString();
        //String encAlgorithm = "AES/CBC/PKCS5PADDING";
        // todo cases CBC or GCM
        byte[] decryptedData;
        SecretKey key;
        key = new SecretKeySpec(encryptionKey, "AES"); //AES-256 key
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance(transformation);
            if (encryptionAlgorithm.equals(EcdhModel.ENCRYPTION_ALGORITHM.AES_CBC_PKCS5PADDING.toString())) {
                cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(initVector));
            } else if (encryptionAlgorithm.equals(EcdhModel.ENCRYPTION_ALGORITHM.AES_GCM_NOPADDING.toString())) {
                cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(16, initVector));
            }
            decryptedData = cipher.doFinal(ciphertext);
        } catch (NoSuchAlgorithmException | IllegalBlockSizeException |
                 BadPaddingException | NoSuchPaddingException |
                 InvalidAlgorithmParameterException | InvalidKeyException e) {
            //throw new RuntimeException(e);
            System.out.println("** Exception: " + e.getMessage());
            return null;
        }
        // build the return model
        return decryptedData;
    }



    public static String generateUuid() {
        UUID uuid = UUID.randomUUID();
        return uuid.toString();
    }

    private static byte[] generateRandomNumber(int length) {
        if (length < 1) return null;
        byte[] number = new byte[length];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(number);
        return number;
    }

    public static String base64EncodingNpe(byte[] input) {
        if (input == null) return null;
        return Base64.encodeToString(input, Base64.NO_WRAP);
    }

    public static byte[] base64Decoding(String input) {
        if (TextUtils.isEmpty(input)) return null;
        return Base64.decode(input, Base64.NO_WRAP);
    }

}
